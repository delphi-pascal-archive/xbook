<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0033)http://delphi.aiq.ru/stati/26.htm -->
<HTML><HEAD><TITLE>Статьи > Сделай сам или DBTreeView своими руками. Сайт DELPHI CITY.</TITLE>
<STYLE type=text/css>A {
	COLOR: #000000; TEXT-DECORATION: none
}
A:hover {
	TEXT-DECORATION: underline
}
</STYLE>

<META http-equiv=content-style-type content=text/css>
<META http-equiv=Content-type content="text/html; charset=windows-1251">
<META content="MSHTML 6.00.2723.2500" name=GENERATOR></HEAD>
<BODY 
style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px" 
bgColor=#e9ecf3 leftMargin=0 topMargin=0>
  <TR>
    <TD style="BORDER-BOTTOM: rgb(0,0,0) 1px solid" width=1002 bgColor=#004891 
    colSpan=2 height=1></TD></TR>
<TABLE cellSpacing=0 cellPadding=3 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top width=9999>
      <P><FONT size=3><B><a href="http://delphi.aiq.ru/stati/26.htm" target="_blank"><font color="#0000FF">С 
        д е л а й &nbsp; с а м или DBTreeView своими руками</font></a> </B></FONT> 
        <a href="http://delphi.aiq.ru/"><br>
        <b>Статья с сайта <font color="#0000FF">http://delphi.aiq.ru/ </font></b></a></P>
      <TABLE cellSpacing=0 border=0>
        <TBODY>
        <TR>
          <TD><FONT size=2><B>Введение </B></FONT></TD></TR></TBODY></TABLE>
      <P></P><FONT size=2>В статье речь пойдет об отображении данных, хранящихся 
      в БД и имеющих иерархическую (древовидную) структуру. Визуальное 
      представление таких данных требует соответствующего инструмента. 
      Существует немало компонент, которые позволяют представлять данные в виде 
      дерева — для краткости будем называть их все <B>DB TreeView </B>. 
      Компоненты эти довольно удобны, но, как правило, "заточены" под 
      определенные задачи и каждый "шаг в сторону" в структуре данных заставляет 
      многих пускаться в поиски. И на Круглом Столе появляются вопросы: 
      <EM>"помогите найти компонент DB TreeView, который позволяет делать еще и 
      ..." </EM>и так далее. </FONT>
      <P></P><FONT size=2>А ведь в Delphi существует стандартный компонент для 
      представления древовидных данных, это знакомый всем TTreeView, его 
      возможностей хватает с лихвой практически для всех задач по отображению 
      деревьев. Сделать из TreeView самый настоящий DB TreeView, да еще 
      полностью контролировать его развитие, более перспективный путь, нежели 
      каждый раз искать новый чужой компонент. <BR>Весь этот материал основан на 
      моем личном опыте и, естественно, не обязательно является самым 
      оптимальным вариантом. Это частное мнение, которым я просто хочу 
      поделиться. </FONT>
      <P></P><FONT size=2>Рассмотрим два принципиально разных случая: </FONT>
      <DL>
        <DT><FONT size=2><A 
        href="http://delphi.aiq.ru/stati/26.htm#01"><B>Дерево подразделений 
        </B></A></FONT>
        <DD><FONT size=2>Данные представляют собой классическую древовидную 
        структуру. Глубина вложенности дерева не ограничена, заранее не известна 
        и не одинакова для разных ветвей. Дерево может не иметь общего корневого 
        узла, то есть распадаться на несколько деревьев.; </FONT>
        <DT><FONT size=2><A 
        href="http://delphi.aiq.ru/stati/26.htm#02"><B>Дерево аналитических 
        признаков </B></A></FONT>
        <DD><FONT size=2>Реально данные не являются иерархическими, но могут 
        быть представлены в таком виде. Глубина вложенности дерева одинакова для 
        всех его веток и фиксирована в данном примере. Правило построения 
        иерархии может меняться в режиме run-time. </FONT></DD></DL><FONT 
      size=2>Отличаются эти примеры стуктурой данных и, соответственно, способом 
      формирования дерева. <BR>Тем не менее сущестуют общие правила для 
      генерации дерева. Во-первых, я исхожу из предположения, что <B>все дерево 
      сразу </B>с большой степенью вероятности не понадобится пользователю. 
      Более того, сам процесс формирования TTreeView довольно длительный и 
      занимает ощутимое время, особенно если работать с большим объемом БД. 
      <BR>Гораздо правильнее строить отдельные ветки дерева динамически, только 
      в тот момент, когда они наверняка понадобятся. <BR>То есть, в самый 
      начальный момент необходимо сформировать только самый верхний уровень 
      дерева. Затем, по мере требования, можно достраивать очередную ветвь. 
      <BR>Какой же момент можно считать моментом требования? В принципе есть два 
      равнозначных варианта и отличаются они только внешним видом. 
      <BR><B>Первый: </B>по двойному клику на текущей ветви дерева проверять, 
      была ли она достроена, если нет то формировать ее и генерировать событие 
      OnExpanding, раскрывая новую ветвь. <BR><B>Второй: </B>при попытке 
      "раскрыть" ветку проводить аналогичные действия. </FONT>
      <P></P><FONT size=2>Основное отличие этих подходов: в первом случае 
      пользователю необходимо сделать явно лишнее и не очень естественное для 
      дерева движение , то есть двойной клик. А во втором случае мы должны 
      обеспечить возможность раскрытия для каждой ветки дерева, ведь если у 
      ветви нет значка [+] , то и попытаться раскрыть ее будет невозможно. А 
      значит для всех новых, свеже сформированных ветвей, принудительно нужно 
      обеспечить существования фиктивной дочерней ветви. <BR>Можете сами 
      выбрать, что Вам удобнее, я использую второй вариант. </FONT>
      <P></P><FONT size=2>На сервере <A 
      href="http://ib.demo.ru/">http://ib.demo.ru/</A>была опубликована статья 
      Кузьменко Дмитрия <STRONG><A 
      href="http://ib.demo.ru/devinfo/treedb.htm">Древовидные (иерархические) 
      структуры данных в реляционных базах данных </A></STRONG>, часть которой 
      посвящена теме визуального представления древовидных данных. В этой статье 
      предлагалось хранить в таблице дополнительное поле с количеством дочерних 
      записей для каждой ветви именно для того, чтобы иметь возможность 
      принимать решение рисовать или не рисовать знак [+] возле текущей ветки 
      дерева. То есть на ходу определять, имеет ли шанс эта ветка быть 
      раскрытой. <BR>Следовательно, только для процесса визуализации требуется 
      изменять структуру данных, добавлять триггеры для сохранения целостности 
      дополнительной информации. <BR>Каждый способ имеет свои достоинства и 
      недостатки, но мне кажется несколько неоправданным такой подход, когда 
      структура таблиц зависит от способа их отображаения. В примерах, которые 
      иллюстрируют материал этой статьи применяется использование фиктивных 
      дочерних ветвей для обеспечения появления у каждой ветви значка [+]. 
      </FONT>
      <P><FONT size=2><B>Примечание: </B><BR><EM>Такой вопрос, как способы 
      представления иерархических данных в БД, не является предметом данной 
      статьи. <BR>Пример построен на локальных Paradox-таблицах. Следовательно 
      для переноса его на SQL-серверные БД стоит учитывать их особенности. 
      </EM></FONT></P>
      <P><FONT size=2><A name=01></A></FONT></P>
      <TABLE cellSpacing=0 border=0>
        <TBODY>
        <TR>
          <TD><FONT size=2><B>Дерево подразделеений 
      </B></FONT></TD></TR></TBODY></TABLE>
      <P></P><FONT size=2>Пусть у нас существует таблица подразделений, каждое 
      из которых может иметь свои внутренние подразделения. Необходимо 
      отображать эти данные в виде дерева. <BR>Используемая в примере таблица — 
      COMPANY.DB <BR>Структура данных реализована классическим деревом: каждая 
      запись о подразделении представлена полями </FONT>
      <UL>
        <LI><FONT size=2><B>CompanyID </B>— номер подразделения </FONT>
        <LI><FONT size=2><B>ParentID </B>— номер родительского подразделения 
        </FONT>
        <LI><FONT size=2><B>Name </B>— название. </FONT></LI></UL><FONT size=2>Для 
      тех подразделений, которые не имеют головных над собой, поле ParentID 
      равно 0. </FONT>
      <P></P><FONT size=2>Формировать уровни дерева мы будем с помощью запроса к 
      таблице ( компонент qTreeCompanies : TQuery ). <PRE>Select * From COMPANY
Where ParentID=:ParentID
</PRE>Параметр ParentID будет определять, какую ветку мы сейчас 
      достраиваем. То есть, к какой ищем дочерние подразделения. <BR>Процедура, 
      формирующая очередной уровень (дочерний для ветви Node ) реализована 
      следующим образом: <PRE>Procedure TFormTree.ExpandLevel( Node : TTreeNode);
Var ID , i   : Integer;
    TreeNode : TTreeNode;
Begin

    

// Для самого верхнего уровня выбрать только тех,
    // кто не имеет родителей.

    IF Node = nil Then ID:=0
    Else ID:=Integer(Node.Data);

    qTreeCompanies.Close;
    qTreeCompanies.ParamByName(

'ParentID'

).AsInteger:=ID;
    qTreeCompanies.Open;
							   
    TreeCompanies.Items.BeginUpdate;
	
    

// Для каждой строки из полученного набора данных
    // формируем ветвь в TreeView, как дочерние ветки к той,
    // которую мы только что "раскрыли"

    For i:=1 To qTreeCompanies.RecordCount Do
    Begin

       

// Запишем в поле Data ветки ее идентификационный номер(ID) в таблице

    TreeNode:=TreeCompanies.Items.AddChildObject(Node ,
                            qTreeCompanies.FieldByName(

'Name'

).AsString ,
                          Pointer(qTreeCompanies.FieldByName(

'ID'

).AsInteger));

      TreeNode.ImageIndex:=1;
      TreeNode.SelectedIndex:=2;

       

// Добавим фиктивную (пустую) дочернюю ветвь только для того,
       // чтобы был отрисован [+] на ветке и ее можно было бы раскрыть

       TreeCompanies.Items.AddChildObject(TreeNode , 

''

 , nil);

       qTreeCompanies.Next;
    End;			
	
    TreeCompanies.Items.EndUpdate;

End; 
</PRE>Теперь позаботимся о том, чтобы она вызывалась в нужный нам момент 
      времени. На событие <B>OnExpanding </B>проверим, есть ли у текущей ветки 
      фиктивная дочерняя ветвь и, если она есть, сформируем реальную ветку, 
      предварительно удалив фиктивную. <PRE>  IF Node.getFirstChild.Data = nil
  Then Begin
          Node.DeleteChildren;
          ExpandLevel(Node);
       End;
</PRE></FONT>
      <P><FONT size=2><IMG height=291 alt="" hspace=10 
      src="Статьи  Сделай сам или DBTreeView своими руками_ Сайт DELPHI CITY.files/dbtree1.gif" 
      width=518 vspace=10 border=0> </FONT></P><FONT size=2>На форме в проекте 
      кроме дерева расположена еще и сетка (Grid), в которой отображаются записи 
      текущего уровня подразделений. Это, по сути, список дочерних ветвей для 
      текущей ветки дерева. Для того, чтобы синхронизировать TreeView и DBGrid 
      используем нехитрый прием — на событие TTreeView.OnChange (шаг по ветке) 
      добавим следующий код: <PRE>    
  IF TreeCompanies.Selected &lt;&gt; nil Then
   Begin
       

//ID родительской ветки , для нее и ищем все дочерние

   ID:=Integer(TreeCompanies.Selected.Data);

   qCompanies.Close;
    qCompanies.ParamByName(

'ParentID'

).AsInteger:=ID;
       qCompanies.Open;

   End;
</PRE></FONT>
      <P></P><FONT size=2>Помните, в процедуре <B>ExpandLevel </B>мы записывали 
      в поле Data каждой ветки ее идентификационный номер? Вот его то мы сейчас 
      и используем. <BR>Для полного ощущения передвижения по Grid'у, как по 
      дереву можно добавить эффект "проваливания" на более глубокий уровень. По 
      двойному клику на записи в Grid'е пользователь проваливается на один 
      уровень вниз по иерархии, если такой уровень, конечно же еще есть. <BR>На 
      событие OnDblClick для грида: <PRE>    ID:=qCompanies.FieldByName(

'ID'

).AsInteger;

          

// принудительное "невидимое" раскрытие той ветки, на которой стоим

 TreeCompanies.OnExpanding(TreeCompanies ,TreeCompanies.Selected , Allow);

          

// Перебираем все получившиеся дочерние ветки и ищем ту, ID которой
// совпадает с ID строки в правой таблице. То есть ищем ветку в дереве,
// которая соответсвует той записи в таблице, на которой мы стоим
// Как только нашли, визуально раскрываем ветку и делаем ее выделенной,
// то есть визуально "встаем" на нее в дереве

   FOR i:=0 To TreeCompanies.Selected.Count-1 Do
   IF Integer(TreeCompanies.Selected.Item[i].Data) = ID
     Then Begin
          TreeCompanies.Selected.Item[i].Expand(False);
          TreeCompanies.Selected.Item[i].Selected:=True;
          TreeCompanies.Repaint;
          Exit;
         End;
</PRE>Параллельно с этим раскрывается соответствующая ветка самого дерева. 
      Очень эффектно. :о) </FONT>
      <P></P><FONT size=2>В проекте реализована возможность добавления новых 
      ветвей, то есть новых подразделений. Нажимте на TreeView правую кнопку 
      мышки и достраивайте наше дерево, как Вам угодно! </FONT>
      <P><FONT size=2><A name=02></A></FONT></P>
      <TABLE cellSpacing=0 border=0>
        <TBODY>
        <TR>
          <TD><FONT size=2><B>Дерево аналитических признаков 
        </B></FONT></TD></TR></TBODY></TABLE>
      <P align=right><FONT size=2><I>"Куст — это пучок веток, растущих из одного 
      места" </I><BR>из военных афоризмов </FONT></P><FONT size=2>Пусть у нас 
      есть таблица документов, каждый документ, например, описывает некоторую 
      операцию по покупке( или продаже ) товара. В этой операции участвуют: 
      определенный товар, клиент, у которого куплен (или которому продан) этот 
      товар, и город, в котором данная операция совершена. Таким образом, мы 
      имеем таблицу документов, каждая запись в которой наделена тремя 
      аналитическими признаками: <B>Город, Клиент и Товар. </B><BR>По сути своей 
      эти данные не являются иерархическими, и никакой явной зависимости между 
      документами не прослеживается. Но тем не менее эта связь существует — 
      одинаковые аналитические признаки. Например, в одну группу можно 
      объединить все документы, имеющие отношение к определенному товару или 
      клиенту. <BR>Если для анализа данных пользователю необходимо работать с 
      документами по зафиксированным аналитическим признакам, то возникает 
      задача визуального представления таких данных. К примеру, заказчик требует 
      показывать ему все документы для определенного города, а потом, для 
      определенного клиента и товара, но в том же городе. Однако желательно 
      видеть информацию ровно в обратном порядке: сначала выбрать документы с 
      нужным товаром, затем увидеть все города, где работали с этим товаром, 
      выбирать нужный город и так далее. <BR>Явно прослеживается древовидная 
      структура, где каждый уровень дерева суть аналитический признак. Именно 
      поэтому, как говорилось выше, в данном дереве фиксирована глубина 
      вложенности. Она однозначно определяется количеством аналитики для 
      документа. </FONT>
      <P><FONT size=2><STRONG>Описание примера, реализующего данную задачу 
      </STRONG></FONT></P><FONT size=2>Используемые таблицы: <BR>Таблица 
      документов DOCUMENTS.DB , где каждый документ определен полями: </FONT>
      <UL>
        <LI><FONT size=2><B>DocumentID </B>: номер документа </FONT>
        <LI><FONT size=2><B>Name </B>: название </FONT>
        <LI><FONT size=2><B>CityID </B>: ID города </FONT>
        <LI><FONT size=2><B>ClientID </B>: ID клиента </FONT>
        <LI><FONT size=2><B>GoodsID </B>: ID товара </FONT></LI></UL><FONT 
      size=2>Таблицы аналитики, соответственно CITIES.DB, CLIENTS.DB и GOODS.DB, 
      содержат поля названия <STRONG>Name </STRONG>и номера ( <STRONG>CityID 
      </STRONG>, <STRONG>ClientID </STRONG>, <STRONG>GoodID </STRONG>). </FONT>
      <P><FONT size=2><IMG height=291 alt="" hspace=10 
      src="Статьи  Сделай сам или DBTreeView своими руками_ Сайт DELPHI CITY.files/dbtree2.gif" 
      width=518 vspace=10 border=0> </FONT></P><FONT size=2>Так как порядок 
      следования аналитики произвольный, зараннее невозможно написать текст 
      SQL-запроса, который будет возвращать данные для очередного уровня дерева. 
      Этот текст придется формировать в run-time, когда все данные будут 
      известны. <BR>Чтобы не зашиваться именно на такой список аналитики, 
      который приведен в примере, стоит затратить немного больше сил и 
      обеспечить себе некоторую универсальность. Для этого добавим еще одну 
      таблицу (таблицу сущностей) <STRONG>Entities </STRONG>, содержащую 
      описание используемой аналитики. <BR>Поля таблицы ENTITIES.DB </FONT>
      <UL>
        <LI><FONT size=2><STRONG>EntityID </STRONG>— идентификатор </FONT>
        <LI><FONT size=2><STRONG>Name </STRONG>— русское название аналитического 
        признака </FONT>
        <LI><FONT size=2><STRONG>TableName </STRONG>— название таблицы, в 
        которой он содержится </FONT>
        <LI><FONT size=2><STRONG>KeyColumn </STRONG>— ключевой столбец этой 
        таблицы </FONT>
        <LI><FONT size=2><STRONG>OrderNo </STRONG>— номер по порядку в списке 
        используемых признаков </FONT>
        <LI><FONT size=2><STRONG>IsSelect </STRONG>— выбран или не выбран в 
        текущий список признаков </FONT>
        <LI><FONT size=2><STRONG>ImageIndex </STRONG>— номер изображения 
        (используется в отображении дерева) </FONT></LI></UL><FONT size=2>В нашем 
      случае эта таблица будет выглядеть так : </FONT>
      <TABLE cellSpacing=0 cellPadding=0 border=0>
        <TBODY>
        <TR>
          <TD>
            <TABLE cellSpacing=1 border=0>
              <TBODY>
              <TR>
                <TD><FONT size=2><STRONG>EntityID </STRONG></FONT></TD>
                <TD><FONT size=2><STRONG>Name </STRONG></FONT></TD>
                <TD><FONT size=2><STRONG>TableName </STRONG></FONT></TD>
                <TD><FONT size=2><STRONG>KeyColumn </STRONG></FONT></TD>
                <TD><FONT size=2>... </FONT></TD></TR>
              <TR>
                <TD><FONT size=2>1 </FONT></TD>
                <TD><FONT size=2>Город </FONT></TD>
                <TD><FONT size=2>CITIES </FONT></TD>
                <TD><FONT size=2>CityID </FONT></TD>
                <TD><FONT size=2>... </FONT></TD></TR>
              <TR>
                <TD><FONT size=2>2 </FONT></TD>
                <TD><FONT size=2>Товар </FONT></TD>
                <TD><FONT size=2>GOODS </FONT></TD>
                <TD><FONT size=2>GoodID </FONT></TD>
                <TD><FONT size=2>... </FONT></TD></TR>
              <TR>
                <TD><FONT size=2>3 </FONT></TD>
                <TD><FONT size=2>Клиент </FONT></TD>
                <TD><FONT size=2>CLIENTS </FONT></TD>
                <TD><FONT size=2>ClientID </FONT></TD>
                <TD><FONT size=2>... 
      </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
      <P></P><FONT size=2>В примере я использую список <STRONG>ListEntities 
      </STRONG>(TCollection), каждый элемент которого содержит поля TableName, 
      KeyColumn и ImageIndex. Элементы в этом списке расположены в том порядке, 
      в каком будет строиться дерево. Заполняется этот список только той 
      аналитикой, которая требуется для конкретного дерева. Например, только 
      города и клиенты или товары и клиенты, или сразу все вместе. Следовательно 
      этот список (ListEntities) и содержит полную информацию для построения 
      дерева в каждый конкретный момент. <BR>Заполнение списка аналитики 
      проводится в модуле <STRONG>setupEntities.pas </STRONG>. <BR>Процедура 
      <TT>GetEntities( var List : TEntityLists );<BR>&nbsp; </TT>считывает 
      аналитику из таблицы, <BR>а функция <TT>SetEntities( var List : 
      TEntityLists ) : Boolean;</TT><BR>вызывает диалог для настойки аналитики 
      пользователем. </FONT>
      <P></P><FONT size=2>Формирование дерева в этом случае полностью аналогично 
      предыдущему примеру, с той только разницей, которая касается формирования 
      текста запроса для каждого уровня дерева. <BR>Так же в дерево добавляется 
      единый для всех веток самый верхний корневой узел. С точки зрения 
      аналитики это "фиктивный" узел, так как он будет отображать ВСЕ документы, 
      без указания конкретного значения аналитического признака. Кроме того, 
      достраивается еще один, самый нижний уровень — список документов по 
      зафиксированной для текущей ветки аналитики. <BR>Наличие этих "фиктивных" 
      узлов совершенно не обязательно, но, на мой взгляд, очень логично. <BR>В 
      итоге, глубина вложенности дерева будет равна "количество аналитики" + 2 . 
      </FONT>
      <P></P><FONT size=2>Итак, процедура <STRONG>ExpandLevel </STRONG>будет 
      модифицирована следующим образом: </FONT><PRE><FONT size=2>
Procedure TFormTree.ExpandLevelAnalytic(Node : TTreeNode );
Var
 NewItem    : TListsItem;
 ImageIndex ,
 Level , i  : Integer;
 TreeNode   : TTreeNode;
 Sql,Name   : String;
Begin

     IF Node = nil Then Exit;

     TreeAnalytic.Items.BeginUpdate;

     Level:=Node.Level + 1; 

// уровень, который будет раскрываться
</FONT>
<FONT size=2>
// Самому первому аналитическому признаку в списке  ListEntities
// соответсвует _второй_ физический уровень веток дерева.
// Так как самый верхний уровень дерева фиктивный -"все документы"
// Отсюда и игра с (+/-) 1 при обращении к списку


     qTreeAnalytic.Close;

     

// Определим, на каком типе уровня мы сейчас находимся
//

  IF Level &gt; ListEntities.Count
   Then Begin 

 // Уровень документов, аналитка закончилась

    Sql:=

'SELECT * FROM Documents Where '

+ GetSqlPath(Node);
            Name:= 

'DocumentID'

;
            ImageIndex:=3;
          End
     Else Begin 

// Очередной уровень аналитики

            Sql:=

'SELECT DISTINCT '

+ ListEntities[Level-1].AsString + 

'.* '

 +
                 

' FROM Documents , ' 

+  ListEntities[Level-1].AsString + 

' WHERE '

 +
     ListEntities[Level-1].AsString + 

'.'

 +ListEntities[Level-1].Name + 

'='

 +
                 

'Documents.'

+ListEntities[Level-1].Name + 

' AND '

 + GetSqlPath(Node) ;
   Name:=ListEntities[Level-1].Name;
   ImageIndex:=ListEntities[Level-1].ImageIndex;
          End;

     qTreeAnalytic.Sql.Clear;
     qTreeAnalytic.Sql.Add(Sql);

     qTreeAnalytic.Open;
					 

	 // Получен очередной уровень ветвей дерева

 For i:=1 To qTreeAnalytic.RecordCount Do
     Begin
 NewItem:=List.AddItem(qTreeAnalytic.FieldByName(Name).AsInteger , Name);

         TreeNode:=TreeAnalytic.Items.AddChildObject( Node ,
               qTreeAnalytic.FieldByName(

'Name'

).AsString, NewItem );
         TreeNode.ImageIndex:=ImageIndex;
         TreeNode.SelectedIndex:=TreeNode.ImageIndex;

         

// Фиктивная дочерняя ветка ТОЛЬКО для уровней аналитики,
// так как документы - последний уровень, за которым ничего и не может быть

         IF Level &lt;= ListEntities.Count
         Then TreeAnalytic.Items.AddChild(TreeNode , 

''

 );

         qTreeAnalytic.Next;
     End;

     TreeAnalytic.Items.EndUpdate;

End;
</FONT></PRE><FONT size=2>В предыдущем примере мы запоминали ID строки из 
      таблицы в поле Data каждой ветви дерева. Сейчас нам не годится такой 
      вариант, так как аналитический признак определяется не одним 
      идентификатором, а целым элементом списка <STRONG>ListEntities </STRONG>, 
      вот его то и надо запоминать. Поэтому в поле Data сохраняется ссылка на 
      конкретный элемент этого списка. Благо это Pointer и записать туда можно 
      все, что угодно. </FONT>
      <P></P><FONT size=2>В процедуре используется функция <STRONG>GetSqlPath 
      </STRONG>, которая возвращает полный путь от корня до указанной ветки 
      дерева. Полный путь это есть зафиксированные значения для каждого уровня 
      аналитики. Эти значения необходимы для того, чтобы верно построить запрос. 
      То есть мы фактически формируем дополнительный фильтр для последующих 
      выборок, напрмер — получаем всех клиентов для конкретного города и 
      указанного товара. <PRE>Function TFormTree.GetSqlPath( Node : TTreeNode ) : String;
Begin
   Result:=

' 0=0 '

 ;

   

// Участвуют все ветви дерева, кроме самого верхнего фиктивного уровня

   While Node.Level &gt; 0   Do
   Begin
      Result:= Result + 

' AND ' 

+
               

'Documents.'

 + TListsItem(Node.Data).Name + 

'='

 +
                              TListsItem(Node.Data).AsString ;

      

// Делаем шаг назад по ветке дерева

      Node:=Node.Parent;
   End;

End;
</PRE></FONT>
      <P><FONT size=2><STRONG>Пример текстов SQL запроса, который будет 
      сформирован при движении по дереву: </STRONG></FONT></P><FONT 
      size=2>Уровень "товары" — <EM>Все товары, которые встречаются в 
      документах, созданных в городе номер 6 и для клиента номер 3 </EM></FONT><PRE><FONT size=2>
SELECT
</FONT>
<FONT size=2>
DISTINCT

 Goods.*  

FROM

 Documents , Goods 

WHERE

 Goods.GoodsID=Documents.GoodsID AND  0=0  
AND Documents.CityID=6 AND Documents.ClientID=3
</FONT></PRE><FONT size=2>Последний уровень "документы" — <EM>Все 
      документы, созданные в городе номер 6 и для клиента номер 3, по товару 
      номер 1 </EM></FONT><PRE><FONT size=2>
SELECT

 * 

FROM

 Documents 

Where

  0=0  AND 
Documents.GoodsID=1 AND Documents.CityID=6 AND Documents.ClientID=3
</FONT></PRE>
      <P></P><FONT size=2>Такой подход позволяет легко расширять набор 
      аналитических признаков, которые должны использоваться в программе, 
      практически без изменения кода клиентского приложения. Достаточно изменить 
      структуру таблицы DOCUMENTS и дополнить таблицу ENTITIES. </FONT>
      <P></P><FONT size=2>В некоторой степени можно сказать, что таблица 
      ENTITIES содержит метаданные о структуре базы. Правда с большой натяжкой, 
      так как в данном примере структура просто элементарна, а связи слишком 
      просты и не поддерживают никакой глубины вложения (как, например, в таком 
      случае, когда город не указан явно в документе, но может быть вытянут из 
      таблицы клиентов и так далее). <BR>Для получения набора данных не 
      обязательно использовать именно запросы, точно так же можно использовать 
      хранимые процедуры для SQL-серверных СУБД. Изменится структура метаданных, 
      но не изменится принцип формирования дерева. <BR>На мой взгляд, в качестве 
      примера, стоит внимательно рассмотреть такой подход, чтобы вы могли в 
      своих конкретных задачах на его основе конструировать реальные метаданные 
      и без проблем модифицировать дерево аналитических признаков. </FONT>
      <P><FONT size=2><STRONG>Итак... </STRONG></FONT></P>
      <FONT size=2>Итак, были рассмотрены две принципиально разные задачи, а реализация 
      DBTreeView оказалась практически идентична. Собственно, этот факт и является 
      важным результатом статьи — воспользуйтесь примерами, добавьте собственный 
      функционал и создайте для себя несложный компонент для отображения древовидной 
      структуры. Это не значит, что не стоит пользоваться сторонними компонентами, 
      ни в коем случае. Просто если существующие вас не устраивают полностью, 
      вы будете знать, как это исправить. </FONT></TD>
  </TR></TBODY></TABLE></BODY></HTML>
